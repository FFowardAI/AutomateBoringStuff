-- Users of your extension/backend
CREATE TABLE users (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  name          TEXT,
  email         TEXT      UNIQUE,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- A recording session: one user, one record cycle
CREATE TABLE sessions (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID      NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  context       TEXT,          -- initial input context
  started_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at      TIMESTAMPTZ
);

-- Within each session, the actual "record" time‐range
CREATE TABLE recordings (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id    UUID      NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  start_time    TIMESTAMPTZ NOT NULL,
  end_time      TIMESTAMPTZ NOT NULL
);

-- Individual frames/images captured
CREATE TABLE images (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  recording_id  UUID      NOT NULL REFERENCES recordings(id) ON DELETE CASCADE,
  file_path     TEXT      NOT NULL,
  sequence      INT,
  captured_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Scripts generated by your /vlm endpoint
CREATE TABLE scripts (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id    UUID      NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  content       TEXT      NOT NULL,
  status        TEXT      NOT NULL
                      CHECK (status IN ('pending','completed','failed')),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- When the extension "activates" a script with user‐provided context
CREATE TABLE activations (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID      NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  script_id     UUID      NOT NULL REFERENCES scripts(id) ON DELETE CASCADE,
  context       TEXT,       -- extra instructions from the user
  activated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Backend "computer‐use" jobs that actually run the script
CREATE TABLE compute_jobs (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  script_id     UUID      NOT NULL REFERENCES scripts(id) ON DELETE CASCADE,
  context       TEXT,       -- task you send to /computer-use
  status        TEXT      NOT NULL
                      CHECK (status IN ('queued','running','completed','failed')),
  result        TEXT,       -- output or logs from the run
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- All user‐facing notifications
CREATE TABLE notifications (
  id              UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         UUID      NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  script_id       UUID      REFERENCES scripts(id),
  compute_job_id  UUID      REFERENCES compute_jobs(id),
  type            TEXT      NOT NULL
                        CHECK (type IN ('script_ready','compute_done','error')),
  message         TEXT      NOT NULL,
  is_read         BOOLEAN   NOT NULL DEFAULT FALSE,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- (optional) index to quickly find unread notifications
CREATE INDEX idx_notifications_user_unread
  ON notifications(user_id, is_read)
  WHERE is_read = FALSE;

-- Create Storage bucket for images
-- Note: Run this in Supabase dashboard or via API, not as direct SQL
-- INSERT INTO storage.buckets (id, name) VALUES ('session_images', 'session_images'); 